-- 1. CONOCIMIENTOS SQL
-- 1.1) Describe el funcionamiento general de la sentencia JOIN.
Respuesta: Un JOIN sirve para combinar filas de dos tablas Y siempre se tiene que usar una condicion para relacionar dichas tablas, lo
comun para relacionarlas son sus llaves primarias con una llave foranea.
-- 1.2) ¿Cuáles son los tipos de JOIN y cuál es el funcionamiento de los mismos?
Respuesta: 
- INNER JOIN devuelve en la consulta los registros donde hay conincidencia en ambas tablas en base a la condicion dada 
- LEFT JOIN en la consulta devuelve todos los registros de la tabla izquierda, Y los registros que NO tienen coincidencia de la tabla
derecha saldrán NULL
- RIGHT JOIN en la consulta devuelve todos los registros de la tabla derecha, Y los registros que NO tienen coincidencia de la tabla
izquierda saldrán NULL
- FULL JOIN devuelve en la consulta todos los registros de la tabla izquierda Y derecha 
- CROSS JOIN en consulta devuelve lo que se conoce como cartesiano, son todas las posibles combinaciones entre filas de las 2 tablas.
un ejemplo cuando en la tabla izquierda se tienen 10 registros Y en la derecha 20 registros, el total en la cosulta serían 200 registros.
-- 1.3) ¿Cuál el funcionamiento general de los TRIGGER y qué propósito tienen?
Un TRIGGER se dispara automáticamente cuándo ocurre un evento en específico según lo configurado.
Puede dispararse en un evento de INSERT,UPDATE o DELETE Y se ejecuta antes o despues del evento SIN necesidad de que se llame manualmente
o se tenga que ejecutar en una tarea,etc.
-- 1.4) ¿Qué es y para qué sirve un STORED PROCEDURE?
Respuesta: Es un conjunto de sentencias que se guardan en la BD Y puede ejecutarse cuándo se necesiten, se ejecuta en mysql con CALL Y en SQL con
exec.

-- Hacer las consultas necesarias para:
-- 1.5) Traer todos los productos que tengan una venta.
-- inner join es para traer las coincidencias de ambas tablas  y distinct es para evitar los duplicados
SELECT DISTINCT p.idProducto,p.nombre,p.precio FROM castores.productos p INNER JOIN castores.ventas v ON v.idProducto = p.idProducto;

-- 1.6) Traer todos los productos que tengan ventas y la cantidad total de productos vendidos.
-- inner join para traer los productos con ventas, sum(v.cantidad) suma la cantidad del producto, group by para agrupar por id,nombre y precio
SELECT 
p.idProducto, p.nombre, p.precio,SUM(v.cantidad) AS total_vendido
FROM castores.productos p 
INNER JOIN castores.ventas v ON p.idProducto = v.idProducto
GROUP BY p.idProducto, p.nombre, p.precio;

-- 1.7) Traer todos los productos (independientemente de si tienen ventas o no) y la suma total ($) vendida por producto
-- use ifnull para sustituir los null por 0, en este caso usé left join ya que necesito todos los productos de la tabla productos
-- y solamente cuándo se tengan coincidencias en la tabla ventas se suma la cantidad y el total vendido
SELECT 
p.idProducto,p.nombre,p.precio,IFNULL(SUM(v.cantidad),0) AS lovendido,IFNULL(SUM(v.cantidad * p.precio), 0) AS total_vendido
FROM castores.productos p
LEFT JOIN castores.ventas v ON p.idProducto = v.idProducto
GROUP BY p.idProducto, p.nombre, p.precio;

-- Para la generación de la estructura me apoyé de: https://start.spring.io/?utm_source=chatgpt.com
SELECT VERSION();